# -*- coding: utf-8 -*-
"""ExploratoryDataAnalysis-GooglePlayStore.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/144rzqlKmIWMsSJcvPwnSj5aBO1HNKQPW

#  In this work, I will perform Exploratory Data Analysis on the data of **Google Play Store** apps using Python.

# Import libraries:
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt 
import seaborn as sns
import plotly.express as px

"""# Load the dataset:
# Web scraped data of 10k Play Store apps for analysing the Android market.
"""

#Install the Kaggle library. 
!pip install kaggle
#Create a new directory named ".kaggle".
!mkdir ~/.kaggle

#upload the “kaggle.json” file to your Google Drive
#copy the “kaggle.json” file from the mounted google drive to the current instance storage.
!cp /content/drive/MyDrive/kaggle.json ~/.kaggle/kaggle.json 

#Copy the "kaggle.json" file into the newly created directory.
#"kaggle.json" contains the username and the API key
#!cp /kaggle.json ~/.kaggle/
#Grant the necessary permissions for this file.
!chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download lava18/google-play-store-apps -f googleplaystore.csv

!unzip googleplaystore.csv.zip

df = pd.read_csv("googleplaystore.csv")
#df.head()
df.sample(10)

df.info()

"""# Performing an exploratory data analysis on the Google Play Store dataset

- Exploring the data can reveal some interesting insights, so let's dive in.

- Check the data for any missing values and clean the data.
"""

df.isna()

#count the NaN values (the missing value in the data) 
df.isna().sum()

#isna().sum() counts both NaN and None missing values, while isnull().sum() only counts NaN missing values
df.isnull().sum()

#Return boolean Series denoting duplicate rows
df.duplicated()

# delete rows with missing values

df.dropna(inplace=True)
df.isna().sum()

# delete duplicates

df.drop_duplicates(inplace=True)

# Inspect the data types of all columns
df.dtypes

# Check the correlation between columns
corr = df.corr()
sns.heatmap(corr, annot=True)
plt.show()

"""# - One numeric column in the Dataframe.
# - the correlation of a variable with itself is 1.
"""

cat=df.Category.unique()
cat

len(cat)

"""# - There are 33 categories in the dataset. Let's find out which category is the most commonly occurring."""

topCat = df.groupby(by = ["Category"]).size().reset_index(name="Count")
topCat

figure = px.bar(topCat,x='Category',y='Count',title='Categorization of Apps',height = 800)
figure.show()

"""# - The family category is the most frequently occurring

# Distribution of app ratings

We will explore the correlation between **ratings** and **categories** to gain insights.
"""

df.Rating.unique()

topRat = df['Rating'].value_counts()
topRat

figure = px.histogram(df, x="Rating", title='App Ratings Overview',text_auto='.3s', height=800)
figure.show()

"""# - Most of the ratings are concentrated around 4.

# Let's observe the distribution of ratings within each category column.
"""

AverageRatperCat=df.groupby('Category')['Rating'].mean().reset_index(name='Average Rating')
AverageRatperCat

figure=px.bar(AverageRatperCat, x='Category', y='Average Rating', title='Mean score for each category', color='Category',
              text_auto='.3s', height=800)
figure.show()

"""# - Among all categories, "Event" has the highest average rating. However "Dating" category displays the lowest average rating.

# Next, let's determine which category has the highest number of user reviews.
"""

df['Reviews'].unique()

#Convert Reviews to numeric values/from 'object' to 'float'
#df[['Reviews']] = df[['Reviews']].apply(pd.to_numeric)
df['Reviews'] = df['Reviews'].astype(float)
df['Reviews'].unique()
df['Reviews'].dtypes

RevPerCat=df.groupby('Category')['Reviews'].sum().reset_index(name='Total reviews')
RevPerCat

figure= px.line(RevPerCat, x='Category', y='Total reviews', markers=True, title='Distribution of total app reviews for each Category', height=800)
figure.show()

"""# - The Game category has the highest number of reviews.
# - The Event app, however, has a high rating but a relatively low number of reviews.

# Distribution of app installs on each category.
"""

# Check special characters
df['Installs'].unique()

# Clean the 'Installs' data and convert the data type from 'object' to 'float'.
Installs=[]

for x in df.Installs: 
  if ',' in x:
    x = x.replace(',' ,'')
  if '+' in x:
    x = x.replace('+','')
  x=int(x)
  Installs.append(x)

df['Installs']=Installs
df['Installs'] = df['Installs'].astype(float)
df['Installs']

df['Installs'].unique()

InsPerCat=df.groupby('Category')['Installs'].sum().reset_index(name='Total installs')

figure=px.pie(InsPerCat, values='Total installs', names='Category',color_discrete_sequence=px.colors.sequential.Rainbow)
figure.update_layout(title_text='Distribution of total app installation for each Category',height = 800)
figure.update_traces(rotation=90,textposition='inside',textinfo='label+percent+value')

"""# - The most frequently installed category by users are Game, followed by Communication as the second most installed category, and Social as the third most installed category.

# Let's examine the Type column to determine if the app is free or paid.
"""

df['Type'].unique()

typCat = df.groupby('Category')['Type'].value_counts().reset_index(name="Count")
typCat

figure = px.bar(typCat, x="Category", y="Count", color='Type', barmode='group', height=900)
figure.show()

"""# - Once again, the family category has the highest number of both free and paid apps on the Google Play Store.
# - Shopping apps, social apps, entertainment apps, art and design apps, events apps, education apps, comics apps and others are mostly free.
"""